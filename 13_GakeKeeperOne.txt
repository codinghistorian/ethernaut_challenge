Gatekeeper One
Difficulty 5/10

Make it past the gatekeeper and register as an entrant to pass this level.

Things that might help:
Remember what you've learned from the Telephone and Token levels.
You can learn more about the special function gasleft(), in Solidity's documentation (see here and here).

220314 18:17 KST

I think first thing is to make sure that I call this enter() function from a contract.
and also need to use call function to specify gas.

when I did uint16(tx.origin) meaning my wallet address's uint16, it gave me 5285.

so..I think the key should give me the same number when uint64ed and uint32ed.

anyway, it needs to have 5285

so it should definitely have 14 A5 in the beginning of the key.


https://www.tutorialspoint.com/solidity/solidity_conversions.htm

refer to type conversion above.

220315 18:42 KST
clue1

0x14a5b8f7DF340D89F3f7609dedCcE79a416E946c
uint16 => 0x14a5

0x00001415 is (uint32(uint64(_gateKey))
so basically, it means. last digits are 1415

clue2

(uint32(uint64(_gateKey)) != uint64(_gateKey)

for example if
0x14a5b8f7DF340D89F3f7609dedCcE79a416E946c


left hand side of equation is
0x0000000000000000000000000000000000001415

40 jari.

right hand side is
0x0000000000000000000000000000000000001415

bytes8(64 bits) is uint64

there is something on the first part of bytes8 _key.

clue3

fuck it. I will just draw it on paper.

uint64 has 6 digits   2**6
uint16 has 4 digits   2**4
uint32 has 5 digits   2**5

so, the answer should be sth like

0xa014a5



220315 19:06 KST

let's try.

ah, shit. I need to make a smart contract too.

// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract GateKeeperOne {
  address public target = 0x45306D070231294BfF371dbBe6cDED94bE1f079B;
  function goTo(bytes8 _haha) external {
      (bool success , ) = target.call(abi.encodeWithSignature("enter(bytes8)", _haha));
      require(success, "haha");
  }
}

220315 19:12 KST
0x105285
let's try this


a shibal. bit bytes uint dashi bok sup


220316 14:47 KST
hm... I think I need to think all the number as hex then do the conversion.

gotta do the conversion the way solidity does, not some internet converter does.

oh, and gas should have been specified.

contract GateKeeperOne {
  address public target = 0x45306D070231294BfF371dbBe6cDED94bE1f079B;
  function goTo(bytes8 _haha) external {
      (bool success , ) = target.call{gas: 819100}(abi.encodeWithSignature("enter(bytes8)", _haha));
      require(success, "haha");
  }
}

my wallet address is this
0x14a5b8f7DF340D89F3f7609dedCcE79a416E946c

third require of gateThree.
when converted with uint16, only 4 hex remains.
0x946c

when converted to  uint64 leaves only 21 hex
0x7609dedCcE79a416E946c

when the above is converted to uint32, only 8 hex remains
0x416E946c

so, prolly the _gateKey has at the end of it.
0x0000946c

----------------------------

now the first requirement in gatekeyone
right hand side
0x946c

let hand side
0x0000946c
 again.. four zeros and 946c
-------------

anyway, 21 hex in the key. what I got so far is this below
0x0000946c

-----------------
requirement two.

0x7609dedCcE79a0000946c
0x?????????????0000946c
!=
0x0000946c


it means I just need to put in some number in the first part of the hex.

0xasdasdasdasda0000946c

I will try above.

first need to deploy smart contract.
220316 15:03 KST attempt second


0x14a5b8f7DF340D89F3f7609dedCcE79a416E946c

0x0000000000000000000asdasdasdasda0000946c


0x111111110000946c


yeah. 

https://stackoverflow.com/questions/70447003/how-do-i-input-the-parameter-with-bytes4-type-in-remix
I did input 16 hex, but why not working?

220316 15:29 KST
okay. the key is alright but the gas is problem

0x111111110000946c


hm... they used only
https://rinkeby.etherscan.io/tx/0x51b7e0aa523ddfd841f355925fabfcdce19a3a3f6255d68d8a5119b8c0ff7997
27414 of gas.
maybe I should 27414 + 8191 as gas amount

15:46 KST hm.. maybe just 8191..?

hm... 8191000 also did not work.
so how much does gas cost...to call an external function and have a call function in it?
but still. when I call the other contract's function, I specified gas.
maybe I misunderstood mod() in safeMath?? but it should be safeMath's modulo. ain't it?